/* Taller de Diseño de software 2014

   Proyecto: Compilador
   
  - Integrantes:
    - Coria, Gaston
    - Gastaldi, Diego
    
  *************************************
  
  analyzer.cup representa la gramatica 
  del lenguaje a compilar, ademas informa
  errores en ella.
  
*/

package compiler2014;
import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import ir.ast.*;
parser code {:

  public static void main(String[] args){
    try {
      /* Loading the file*/
      FileInputStream file = new FileInputStream(args[0]);/**/
      /* Create lexer analizer with file*/
      yylex lex = new yylex(file);
      /* Create parser analyzer with lex*/  
      parser par = new parser(lex);
      /* Analize file */
      par.setScanner(lex);
      par.parse();
    }catch(Exception x){
      x.printStackTrace();
      System.out.println("Error fatal.\n"); 
    }
  }
  
  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    System.out.println("Mensaje: "+message);
    System.out.println("info: "+info.toString());
    if(info instanceof java_cup.runtime.Symbol) {
        java_cup.runtime.Symbol s=((java_cup.runtime.Symbol)info);
        /* Comprueba si el numero de línea es mayor o igual que cero */
        if(s.left >= 0) {
	        m.append(" en linea "+(s.left+1));
	        /*Comprueba si el numero de columna es mayoro igual que cero */
	        if (s.right >= 0)
	            m.append(", y columna "+(s.right+1));
	        }
        }
    m.append(" : "+message);
    System.err.println(m);
  }
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    System.exit(1);
  }
:}

action code {:
  static symbolTable table = new symbolTable();
  static LinkedList<absSymbol>  declList = new LinkedList<absSymbol>();
  static LinkedList<absSymbol>  parList = new LinkedList<absSymbol>();
  static int blockId = 0;
  private LinkedList<absSymbol> setType(LinkedList<absSymbol> symbolList, String type) {
    for (int i = 0 ; i < symbolList.size() ; i++) {
        symbolList.get(i).type = type;
    }
    return symbolList;
  }
:}


terminal                LPAR, RPAR, LC, RC, LLL, RLL, COMMA, SEMICOLON;
terminal String         ID, WVOID, WBOOLEAN, WBREAK, WCLASS, WINT, WCONTINUE, WELSE, WFLOAT, WFOR, 
                        WIF, WRETURN, WWHILE, WEXTERNINVK;
terminal BinOpType      LESS_THAN, GREATER_THAN, LESS_EQ_THAN, GREATER_EQ_THAN, PLUS, MULT, MINUS, 
                        OR, AND, EQ, NOT_EQ, MODULE, DIV, NOT;
terminal IntLiteral     INT;
terminal FloatLiteral   FLOAT;
terminal BoolLiteral    BOOLEAN;
terminal String         STRING_LITERAL;
terminal AssignStmt     ASSIGN_INC, ASSIGN_DEC, ASSIGN;

non terminal            program, field_decl, externinvk_arg, set_field_decl, set_method_decl,
                        arg_invoc, set_externinvk_arg, expr_, set_externinvk_arg_, set_decl;
non terminal            LinkedList<Expression> expr_parameters, expr_parameters_;
non terminal            Block block;
non terminal            LinkedList<absSymbol> set_complete_id, parameters, set_type_id;
non terminal            String type;
non terminal            Expression expr;
non terminal            AssignStmt assign_op;
non terminal            Statement statement;
non terminal            LinkedList<Statement> set_statement;
non terminal            ReturnStmt stmt_return;
non terminal            IfStmt stmt_if;
non terminal            Literal literal;
non terminal            BinOpExpr bin_op;
non terminal            ArithExpr arith_op;
non terminal            RelExpr rel_op;
non terminal            EqExpr eq_op;
non terminal            CondExpr cond_op;


precedence left EQ, AND, NOT, NOT_EQ;
precedence left OR;
precedence left LESS_THAN, GREATER_THAN, LESS_EQ_THAN, GREATER_EQ_THAN;
precedence left PLUS, MINUS;             
precedence left MULT, DIV, MODULE;             


start with program;

program     	    ::= WCLASS                      {:table.insertLevel();:} 
                        ID:i                        {:if (table.insertSymbol(new simpleSymbol(i, null, "Class")) == null)
                                                        parser.report_error("ID ya difinido: ",i);:}
                        LLL set_decl                {:table.deleteLevel();:} 
                        RLL;

set_decl			::= field_decl SEMICOLON set_decl 
                    |   set_method_decl ;

field_decl		    ::= type:t ID:i LC INT:il RC    {:if (table.insertSymbol(new arraySymbol(i, t, il.getValue(), null)) == null)
                                                        parser.report_error("ID ya difinido: ",i);:}     
                        set_complete_id:s           {:if (table.insertSymbolList(setType(s, t)) == null)
                                                        parser.report_error("ID ya difinido: ",i);:}
                    |   type:t ID:i                 {:if (table.insertSymbol(new simpleSymbol(i, null, t)) == null)
                                                        parser.report_error("ID ya difinido: ",i);:} 
                        set_complete_id:s           {:if (table.insertSymbolList(setType(s, t)) == null)
                                                        parser.report_error("ID ya difinido: ",i);:};
             
set_method_decl		::= type:t ID:i                 {:functionSymbol f = new functionSymbol(i, t, null);
                                                    if (table.insertSymbol(f) == null) {
                                                        parser.report_error("ID ya difinido: ",i);
                                                    }
                                                    table.insertLevel();:} 
                        LPAR parameters:p RPAR      {:if (p != null) {
                                                        ((functionSymbol)table.search(i)).parameters = p;
                                                    }
                                                    if (table.insertSymbolList(p)==null)
                                                        parser.report_error("ID ya difinido: ",p.toString());
                                                    :}
                        block {:table.deleteLevel();:} set_method_decl
                    |   WVOID:t ID:i                {:functionSymbol f = new functionSymbol(i, t, null);
                                                    if (table.insertSymbol(f) == null) {
                                                        parser.report_error("ID ya difinido: ",i);
                                                    }
                                                    table.insertLevel();:} 
                        LPAR parameters:p RPAR      {:if (p != null) {
                                                        ((functionSymbol)table.search(i)).parameters = p;
                                                    }
                                                    if (table.insertSymbolList(p)==null)
                                                        parser.report_error("ID ya difinido: ",p.toString());
                                                    :} 
                        block {:table.deleteLevel();:} set_method_decl
                    |   /*Lambda*/;
    
set_complete_id 	::= COMMA ID:i                  {:declList.add(new simpleSymbol(i, null, null));:} 
                        set_complete_id:s           {:RESULT = s;:} 
                    |   COMMA ID:i LC INT:il RC     {:declList.add(new arraySymbol(i, null, il.getValue(), null));:} 
                        set_complete_id:s           {:RESULT = s;:} 
                    |   /* LAMBDA */                {:RESULT = (LinkedList<absSymbol>)declList.clone(); declList.clear();:};

parameters 		    ::= type:t ID:i                 {:parList.add(new simpleSymbol(i, null, t));:} 
                        set_type_id:s               {:RESULT = s;:} 
                    |   /*LAMBDA*/                  {:RESULT = (LinkedList<absSymbol>)parList.clone(); parList.clear();:};

set_type_id 		::= COMMA type:t ID:i           {:parList.add(new simpleSymbol(i, null, t));:}  
                        set_type_id:s               {:RESULT = s;:} 
                    |   /*LAMBDA*/                  {:RESULT = (LinkedList<absSymbol>)parList.clone(); parList.clear();:};

set_field_decl		::= field_decl SEMICOLON set_field_decl
                    |   /*LAMBDA*/;

statement   		::= ID:i LC expr:e RC                   {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:}
                        assign_op expr SEMICOLON
                    |   ID:i                                {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:}  
                        assign_op expr SEMICOLON
			        |   ID:i LPAR expr_parameters:ep RPAR   {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:} 
			            SEMICOLON                           {::}
			        |   WEXTERNINVK LPAR STRING_LITERAL COMMA type arg_invoc RPAR 			            			        
			        |   WEXTERNINVK LPAR STRING_LITERAL COMMA WVOID arg_invoc RPAR 
    			    |   stmt_if:i 			                {:RESULT = i;:}
	    		    |   WFOR ID:i                           {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:} 
                        ASSIGN expr:e1 COMMA expr:e2 block:b{:RESULT = new ForStmt(i, e1, e2, b);:}
	    		    |   WWHILE expr:e block:b               {:RESULT = new WhileStmt(e, b);:}
	    		    |   stmt_return:r                       {:RESULT = r;:}
	    		    |   WBREAK SEMICOLON                    {:RESULT = new BreakStmt();:}
	    		    |   WCONTINUE SEMICOLON                 {:RESULT = new ContinueStmt();:}
	    		    |   SEMICOLON
	    		    |   block:b                             {:RESULT = b;:} ;
           
stmt_return 		::= WRETURN expr:e SEMICOLON            {:RESULT = new ReturnStmt(e);:}
                    |   WRETURN SEMICOLON                   {:RESULT = new ReturnStmt();:} ;

stmt_if             ::= WIF LPAR expr:e RPAR block:b1 WELSE block:b2    {:RESULT = new IfStmt(e, b1, b2);:}
    			    |   WIF LPAR expr:e RPAR block:b        {:RESULT = new IfStmt(e, b);:} ;

arg_invoc 		    ::= COMMA set_externinvk_arg 
                    |   /* LAMBDA */ ;

set_externinvk_arg 	::= externinvk_arg set_externinvk_arg_ ;

set_externinvk_arg_	::= COMMA set_externinvk_arg 
                    |   /* LAMBDA */ ;

expr_parameters 	::= expr:e expr_parameters_:es              {:LinkedList<Expression> l =new LinkedList<Expression>(es); l.add(e);
                                                                RESULT = l;:}
                    |   /* LAMBDA */                            {:RESULT = new LinkedList<Expression>();:};

expr_parameters_	::= COMMA expr:e expr_parameters_:es        {:LinkedList<Expression> l =new LinkedList<Expression>(es); l.add(e);
                                                                RESULT = l;:}
                    |   /* LAMBDA */                            {:RESULT = new LinkedList<Expression>();:};
                    
set_statement 		::= statement:s set_statement:ss            {:LinkedList<Statement> sets = new LinkedList<Statement>();
                                                                sets.addAll(ss); sets.add(s); RESULT=sets;:} 
                    |   /* LAMBDA */                            {:RESULT = new LinkedList<Statement>();:};

block       		::= LLL                                     {:table.insertLevel();:} 
                        set_field_decl set_statement:s          {:table.deleteLevel();:} 
                        RLL                                     {:RESULT = new Block(blockId, s);:};

type        		::= WFLOAT:w                                {:RESULT = w;:}
                    |   WBOOLEAN:w                              {:RESULT = w;:}
                    |   WINT:w                                  {:RESULT = w;:};

expr        		::= ID:i expr_                              {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:} 
                    |   ID:i LC expr RC expr_                   {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:}
                    |   ID:i LPAR expr_parameters RPAR expr_    {:if (table.search(i) == null) parser.report_error("ID desconocido.",i);:}
			        |   WEXTERNINVK LPAR STRING_LITERAL COMMA type arg_invoc RPAR 
			        |   WEXTERNINVK LPAR STRING_LITERAL COMMA WVOID arg_invoc RPAR 			            
			        |   literal expr_
			        |   MINUS expr expr_
			        |   NOT expr expr_
			        |   LPAR expr RPAR expr_;
			
expr_	    		::= bin_op expr 
                    |   /* LAMBDA */;

externinvk_arg  	::= expr 
                    |   STRING_LITERAL ;

assign_op   		::= ASSIGN:a                                {:RESULT = new SimpleAssign();:}
    			    |   ASSIGN_INC:i                            {:RESULT = new IncrementAssign();:}
    			    |   ASSIGN_DEC:d                            {:RESULT = new DecrementAssign();:};


bin_op      		::= arith_op:a                              {:RESULT = a;:}
                    |   rel_op:r                                {:RESULT = r;:}
                    |   eq_op:e                                 {:RESULT = e;:}
                    |   cond_op:c                               {:RESULT = c;:};

arith_op    		::= PLUS:p                                  {:ArithExpr ar = new ArithExpr(); ar.setOperator(p); RESULT = ar;:} 
                    |   MINUS:m                                 {:ArithExpr ar = new ArithExpr(); ar.setOperator(m); RESULT = ar;:} 
                    |   MULT:m                                  {:ArithExpr ar = new ArithExpr(); ar.setOperator(m); RESULT = ar;:} 
                    |   DIV:d                                   {:ArithExpr ar = new ArithExpr(); ar.setOperator(d); RESULT = ar;:} 
                    |   MODULE:m                                {:ArithExpr ar = new ArithExpr(); ar.setOperator(m); RESULT = ar;:} ;

rel_op      		::= LESS_THAN:l                             {:RelExpr rel = new RelExpr(); rel.setOperator(l); RESULT = rel;:} 
                    |   GREATER_THAN:g                          {:RelExpr rel = new RelExpr(); rel.setOperator(g); RESULT = rel;:} 
                    |   LESS_EQ_THAN:le                         {:RelExpr rel = new RelExpr(); rel.setOperator(le); RESULT = rel;:} 
                    |   GREATER_EQ_THAN:ge                      {:RelExpr rel = new RelExpr(); rel.setOperator(ge); RESULT = rel;:} ;

eq_op       		::= EQ:e                                    {:EqExpr eq = new EqExpr(); eq.setOperator(e); RESULT = eq;:} 
                    |   NOT_EQ:n                                {:EqExpr eq = new EqExpr(); eq.setOperator(n); RESULT = eq;:} ;

cond_op     		::= AND:a                                   {:CondExpr c = new CondExpr(); c.setOperator(a); RESULT = c;:}
                    |   OR:o                                    {:CondExpr c = new CondExpr(); c.setOperator(o); RESULT = c;:} ;

literal     		::= INT:l                                   {:RESULT = l;:}
                    |   FLOAT:l                                 {:RESULT = l;:}
                    |   BOOLEAN:l                               {:RESULT = l;:};

